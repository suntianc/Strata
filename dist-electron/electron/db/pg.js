/**
 * PGlite Database Module
 * Truth source for relational data: tasks, messages, attachments
 */
import { PGlite } from '@electric-sql/pglite';
import path from 'path';
import { app } from 'electron';
let db = null;
export async function initPGlite() {
    if (db)
        return db;
    const dbPath = path.join(app.getPath('userData'), 'strata.db');
    console.log('[PGlite] Initializing database at:', dbPath);
    db = new PGlite(dbPath);
    // Create schema
    await createSchema();
    console.log('[PGlite] Database initialized');
    return db;
}
export function getPGlite() {
    if (!db) {
        throw new Error('[PGlite] Database not initialized. Call initPGlite() first.');
    }
    return db;
}
async function createSchema() {
    if (!db)
        throw new Error('Database not initialized');
    console.log('[PGlite] Creating schema...');
    // Tasks table (UUID generated by application, not by database)
    await db.exec(`
    CREATE TABLE IF NOT EXISTS tasks (
      id UUID PRIMARY KEY,
      parent_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
      title TEXT NOT NULL,
      description TEXT,
      status TEXT DEFAULT 'todo' CHECK (status IN ('todo', 'in_progress', 'blocked', 'done')),
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );

    CREATE INDEX IF NOT EXISTS idx_tasks_parent_id ON tasks(parent_id);
    CREATE INDEX IF NOT EXISTS idx_tasks_status ON tasks(status);
  `);
    // Messages table
    await db.exec(`
    CREATE TABLE IF NOT EXISTS messages (
      id UUID PRIMARY KEY,
      task_id UUID REFERENCES tasks(id) ON DELETE SET NULL,
      content TEXT NOT NULL,
      version INT DEFAULT 1,
      is_archived BOOLEAN DEFAULT FALSE,
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );

    CREATE INDEX IF NOT EXISTS idx_messages_task_id ON messages(task_id);
    CREATE INDEX IF NOT EXISTS idx_messages_archived ON messages(is_archived);
    CREATE INDEX IF NOT EXISTS idx_messages_created_at ON messages(created_at DESC);
  `);
    // Attachments table
    await db.exec(`
    CREATE TABLE IF NOT EXISTS attachments (
      id UUID PRIMARY KEY,
      message_id UUID NOT NULL REFERENCES messages(id) ON DELETE CASCADE,
      file_path TEXT NOT NULL,
      file_type TEXT NOT NULL CHECK (file_type IN ('pdf', 'docx', 'xlsx', 'image', 'code', 'other')),
      file_name TEXT NOT NULL,
      file_size BIGINT,
      summary TEXT,
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );

    CREATE INDEX IF NOT EXISTS idx_attachments_message_id ON attachments(message_id);
  `);
    // Tags table (for UI display)
    await db.exec(`
    CREATE TABLE IF NOT EXISTS message_tags (
      message_id UUID NOT NULL REFERENCES messages(id) ON DELETE CASCADE,
      tag TEXT NOT NULL,
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      PRIMARY KEY (message_id, tag)
    );

    CREATE INDEX IF NOT EXISTS idx_message_tags_tag ON message_tags(tag);
  `);
    // Message relations (for @mentions)
    await db.exec(`
    CREATE TABLE IF NOT EXISTS message_relations (
      from_id UUID NOT NULL REFERENCES messages(id) ON DELETE CASCADE,
      to_id UUID NOT NULL REFERENCES messages(id) ON DELETE CASCADE,
      relation_type TEXT DEFAULT 'refers_to',
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      PRIMARY KEY (from_id, to_id)
    );
  `);
    // Trigger for updated_at
    await db.exec(`
    CREATE OR REPLACE FUNCTION update_updated_at_column()
    RETURNS TRIGGER AS $$
    BEGIN
      NEW.updated_at = CURRENT_TIMESTAMP;
      RETURN NEW;
    END;
    $$ LANGUAGE plpgsql;

    DROP TRIGGER IF EXISTS update_tasks_updated_at ON tasks;
    CREATE TRIGGER update_tasks_updated_at
    BEFORE UPDATE ON tasks
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

    DROP TRIGGER IF EXISTS update_messages_updated_at ON messages;
    CREATE TRIGGER update_messages_updated_at
    BEFORE UPDATE ON messages
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
  `);
    console.log('[PGlite] Schema created successfully');
}
// ========== Helper Functions ==========
export async function query(sql, params = []) {
    const db = getPGlite();
    const result = await db.query(sql, params);
    return result.rows;
}
export async function queryOne(sql, params = []) {
    const rows = await query(sql, params);
    return rows[0] || null;
}
export async function execute(sql, params = []) {
    const db = getPGlite();
    await db.query(sql, params);
}
// Cleanup
export async function closePGlite() {
    if (db) {
        await db.close();
        db = null;
        console.log('[PGlite] Database closed');
    }
}
